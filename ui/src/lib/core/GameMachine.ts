import { verify } from 'o1js';
import type { DataConnection } from 'peerjs';
import{  get, writable, type Unsubscriber, type Writable } from 'svelte/store';
// import { GameObject, GameResult, GameState,PvPChessProgram,PvPChessProgramProof} from 'zkchess-interactive';
import type {PvPChessProgramProof} from 'zkchess-interactive';

class Sync<T>{
	private list:Writable<T[]>=writable([]);
	private subscribe=(fn:(value:T[])=>void)=>this.list.subscribe(fn);
	private unsubscriber:Unsubscriber;
	public push(value:T){
		this.list.update(list=>[...list,value]);
	}
	public consume(){
		const pop=()=>{
			const item=get(this.list)[0];
			// console.warn("Consumed",item);
			this.unsubscriber && this.unsubscriber();
			this.list.update(moves=>moves.slice(1));
			return item;
		}
		// console.log("Consuming",get(this.list),get(this.list).length);
		if(get(this.list).length>0) return pop();
		return new Promise<T>(res=>{
			if(get(this.list).length>0) res(pop());
			else this.unsubscriber=this.list.subscribe(list=>list.length>0&&res(pop()));
		});
	}
}

class GameMachine {
	local:Sync<PvPChessProgramProof>=new Sync();
	network:Sync<PvPChessProgramProof>=new Sync();
	lastProof: Writable<PvPChessProgramProof>;
	fen:Writable<string>;
	constructor(startingProof:PvPChessProgramProof){
		this.lastProof = writable(startingProof);
		this.fen=writable(startingProof.publicOutput.toFEN());
	}
	private async verify(proofLocal:PvPChessProgramProof){
		return true;
	}
	public async playAsWhite(conn:DataConnection) {
		// console.log("Playing as white")
		while(true){
			//try until a valid proof is generated by user
			while(true){
				const proofLocal=await this.local.consume();
				if(await this.verify(proofLocal)){
					console.log(`%c${proofLocal.publicOutput.toAscii()}`,'color:blue;');
					conn.send(proofLocal.toJSON());
					this.lastProof.set(proofLocal);
					break;
				}
			}
			//wait for network proof, retry until a valid proof is generated from network
			while(true){
				const proofNetwork=await this.network.consume();
				if(await this.verify(proofNetwork)){
					console.log(`%c${proofNetwork.publicOutput.toAscii()}`,'color:green;');
					this.fen.set(proofNetwork.publicOutput.toFEN());
					this.lastProof.set(proofNetwork);
					break;
				}
			}
		}
	}
	public async playAsBlack(conn:DataConnection) {
		// console.log("Playing as black")
		while(true){
			//wait for network proof, retry until a valid proof is generated from network
			while(true){
				const proofNetwork=await this.network.consume();
				if(await this.verify(proofNetwork)){
					console.log(`%c${proofNetwork.publicOutput.toAscii()}`,'color:green;');
					this.fen.set(proofNetwork.publicOutput.toFEN());
					this.lastProof.set(proofNetwork);
					break;
				}
			}
			//try until a valid proof is generated by user
			while(true){
				const proofLocal=await this.local.consume();
				if(await this.verify(proofLocal)){
					console.log(`%c${proofLocal.publicOutput.toAscii()}`,'color:blue;');
					conn.send(proofLocal.toJSON());
					this.lastProof.set(proofLocal);
					break;
				}
			}

		}
	}
	// const gs1=await this.network.consume();
	// this.verify();
	// this.gameState.set(gs1);
	// const gs2=await this.local.consume();
	// console.log(`%c${gs2.toAscii()}`,'color:green;');
	// conn.send(gs2.toFEN());
	// this.verify();
	// this.gameState.set(gs2);
	// console.log("GAME ENDED AS " ,gs2.toFEN());
	// const result=Number(get(this.gameState).result.toBigInt());
	// switch(result){
	// 	case GameResult.ONGOING:
	// 		console.log("Ongoing");	
	// 		break;

	// 	case GameResult.ONGOING_OFFERED_DRAW:
	// 		console.log("Ongoing offered draw");
	// 		break;

	// 	case GameResult.ONGOING_AND_STALEMATE_CLAIMED:
	// 		console.log("Ongoing and stalemate claimed");
	// 		break;

	// 	case GameResult.STALEMATE_CLAIM_REPORTED:
	// 		console.log("Stalemate claim reported");
	// 		break;

	// 	case GameResult.WHITE_WINS:
	// 		console.log("White wins");
	// 		break;

	// 	case GameResult.BLACK_WINS:
	// 		console.log("Black wins");
	// 		break;

	// 	case GameResult.DRAW:
	// 		console.log("Draw");
	// 		break;

	// 	case GameResult.DRAW_BY_STALEMATE:
	// 		console.log("Draw by stalemate");
	// 		break;
}
//gs0  gs0
//gs1->gs1
//gs2<-gs2
//gs3->gs3
export default GameMachine;