import Sync from '$lib/Sync';
import type { DataConnection } from 'peerjs';
import { writable, type Writable } from 'svelte/store';
// import { GameObject, GameResult, GameState,PvPChessProgram,PvPChessProgramProof} from 'zkchess-interactive';
import { GameResult, type PvPChessProgramProof } from 'zkchess-interactive';

class GameMachine {
	local: Sync<PvPChessProgramProof> = new Sync();
	network: Sync<PvPChessProgramProof> = new Sync();
	lastProof: Writable<PvPChessProgramProof>;
	fen: Writable<string>;
	onStart:()=>void;
	onDrawOffered:()=>void;
	onOngoing:()=>void;
	onDraw:()=>void;
	onWin:()=>void;
	onLoose:()=>void;
	playingAsBlack:boolean;
	constructor(startingProof: PvPChessProgramProof) {
		this.lastProof = writable(startingProof);
		this.fen = writable(startingProof.publicOutput.toFEN());
		this.onStart=()=>{};
		this.onOngoing=()=>{};
		this.onDrawOffered=()=>{};
		this.onDraw=()=>{};
		this.onWin=()=>{};
		this.onLoose=()=>{};
	}
	private async verify(proof: PvPChessProgramProof) {
		const nextTurnIsOfWhite = proof.publicOutput.turn.toBoolean();
		const nextTurnIsMine=nextTurnIsOfWhite===!this.playingAsBlack;
		const result=Number(proof.publicOutput.result.toBigInt());
			switch(result){
				case GameResult.ONGOING:
					console.log("Ongoing");
					nextTurnIsMine && this.onOngoing();
					break;
				case GameResult.ONGOING_OFFERED_DRAW:
					console.log("Ongoing offered draw");
					nextTurnIsMine && this.onDrawOffered();
					break;

				case GameResult.ONGOING_AND_STALEMATE_CLAIMED:
					console.log("Ongoing and stalemate claimed");
					break;

				case GameResult.STALEMATE_CLAIM_REPORTED:
					console.log("Stalemate claim reported");
					break;

				case GameResult.WHITE_WINS:
					console.log("White wins");
					nextTurnIsMine?this.onWin():this.onLoose();
					break;

				case GameResult.BLACK_WINS:
					console.log("Black wins");
					nextTurnIsMine?this.onWin():this.onLoose();
					break;

				case GameResult.DRAW:
					console.log("Draw");
					nextTurnIsMine && this.onDraw();
					break;

				case GameResult.DRAW_BY_STALEMATE:
					console.log("Draw by stalemate");
					nextTurnIsMine && this.onDraw();
					break;
			}
		return true;
	}
	private async repeatUntilValidLocalProof(conn: DataConnection) {
		// eslint-disable-next-line no-constant-condition
		while (true) {
			const proofLocal = await this.local.consume();
			if (await this.verify(proofLocal)) {
				console.log(`%c${proofLocal.publicOutput.toAscii()}`, 'color:blue;');
				this.fen.set(proofLocal.publicOutput.toFEN());
				conn.send(proofLocal.toJSON());
				this.lastProof.set(proofLocal);
				break;
			}
		}
	}
	private async repeatUntilValidNetworkProof() {
		// eslint-disable-next-line no-constant-condition
		while (true) {
			const proofNetwork = await this.network.consume();
			if (await this.verify(proofNetwork)) {
				console.log(`%c${proofNetwork.publicOutput.toAscii()}`, 'color:green;');
				this.fen.set(proofNetwork.publicOutput.toFEN());
				this.lastProof.set(proofNetwork);
				break;
			}
		}
	}
	public async playAsWhite(conn: DataConnection) {
		this.playingAsBlack=false;
		// console.log("Playing as white")
		await this.repeatUntilValidNetworkProof();
		this.onStart();
		// eslint-disable-next-line no-constant-condition
		while (true) {
			//try until a valid proof is generated by user
			await this.repeatUntilValidLocalProof(conn);
			//wait for network proof, retry until a valid proof is generated from network
			await this.repeatUntilValidNetworkProof();
		}
	}
	public async playAsBlack(conn: DataConnection) {
		this.playingAsBlack=true;
		// console.log("Playing as black")
		await this.repeatUntilValidNetworkProof();
		this.onStart();
		// eslint-disable-next-line no-constant-condition
		while (true) {
			//wait for network proof, retry until a valid proof is generated from network
			await this.repeatUntilValidNetworkProof();
			//try until a valid proof is generated by user
			await this.repeatUntilValidLocalProof(conn);
		}
	}
}
export default GameMachine;
