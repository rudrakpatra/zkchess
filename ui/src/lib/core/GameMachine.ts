import Sync from '$lib/Sync';
import type { DataConnection } from 'peerjs';
import { writable, type Writable } from 'svelte/store';
// import { GameObject, GameResult, GameState,PvPChessProgram,PvPChessProgramProof} from 'zkchess-interactive';
import type { PvPChessProgramProof } from 'zkchess-interactive';

class GameMachine {
	local: Sync<PvPChessProgramProof> = new Sync();
	network: Sync<PvPChessProgramProof> = new Sync();
	lastProof: Writable<PvPChessProgramProof>;
	fen: Writable<string>;
	constructor(startingProof: PvPChessProgramProof) {
		this.lastProof = writable(startingProof);
		this.fen = writable(startingProof.publicOutput.toFEN());
	}
	private async verify(proofLocal: PvPChessProgramProof) {
		console.log(proofLocal);
		return true;
	}
	public async playAsWhite(conn: DataConnection) {
		// console.log("Playing as white")
		// eslint-disable-next-line no-constant-condition
		while (true) {
			//try until a valid proof is generated by user
			// eslint-disable-next-line no-constant-condition
			while (true) {
				const proofLocal = await this.local.consume();
				if (await this.verify(proofLocal)) {
					console.log(`%c${proofLocal.publicOutput.toAscii()}`, 'color:blue;');
					this.fen.set(proofLocal.publicOutput.toFEN());
					conn.send(proofLocal.toJSON());
					this.lastProof.set(proofLocal);
					break;
				}
			}
			//wait for network proof, retry until a valid proof is generated from network
			// eslint-disable-next-line no-constant-condition
			while (true) {
				const proofNetwork = await this.network.consume();
				if (await this.verify(proofNetwork)) {
					console.log(`%c${proofNetwork.publicOutput.toAscii()}`, 'color:green;');
					this.fen.set(proofNetwork.publicOutput.toFEN());
					this.lastProof.set(proofNetwork);
					break;
				}
			}
		}
	}
	public async playAsBlack(conn: DataConnection) {
		// console.log("Playing as black")
		// eslint-disable-next-line no-constant-condition
		while (true) {
			//wait for network proof, retry until a valid proof is generated from network
			// eslint-disable-next-line no-constant-condition
			while (true) {
				const proofNetwork = await this.network.consume();
				if (await this.verify(proofNetwork)) {
					console.log(`%c${proofNetwork.publicOutput.toAscii()}`, 'color:green;');
					this.fen.set(proofNetwork.publicOutput.toFEN());
					this.lastProof.set(proofNetwork);
					break;
				}
			}
			//try until a valid proof is generated by user
			// eslint-disable-next-line no-constant-condition
			while (true) {
				const proofLocal = await this.local.consume();
				if (await this.verify(proofLocal)) {
					console.log(`%c${proofLocal.publicOutput.toAscii()}`, 'color:blue;');
					this.fen.set(proofLocal.publicOutput.toFEN());
					conn.send(proofLocal.toJSON());
					this.lastProof.set(proofLocal);
					break;
				}
			}
		}
	}
	// const gs1=await this.network.consume();
	// this.verify();
	// this.gameState.set(gs1);
	// const gs2=await this.local.consume();
	// console.log(`%c${gs2.toAscii()}`,'color:green;');
	// conn.send(gs2.toFEN());
	// this.verify();
	// this.gameState.set(gs2);
	// console.log("GAME ENDED AS " ,gs2.toFEN());
	// const result=Number(get(this.gameState).result.toBigInt());
	// switch(result){
	// 	case GameResult.ONGOING:
	// 		console.log("Ongoing");
	// 		break;

	// 	case GameResult.ONGOING_OFFERED_DRAW:
	// 		console.log("Ongoing offered draw");
	// 		break;

	// 	case GameResult.ONGOING_AND_STALEMATE_CLAIMED:
	// 		console.log("Ongoing and stalemate claimed");
	// 		break;

	// 	case GameResult.STALEMATE_CLAIM_REPORTED:
	// 		console.log("Stalemate claim reported");
	// 		break;

	// 	case GameResult.WHITE_WINS:
	// 		console.log("White wins");
	// 		break;

	// 	case GameResult.BLACK_WINS:
	// 		console.log("Black wins");
	// 		break;

	// 	case GameResult.DRAW:
	// 		console.log("Draw");
	// 		break;

	// 	case GameResult.DRAW_BY_STALEMATE:
	// 		console.log("Draw by stalemate");
	// 		break;
}
//gs0  gs0
//gs1->gs1
//gs2<-gs2
//gs3->gs3
export default GameMachine;
